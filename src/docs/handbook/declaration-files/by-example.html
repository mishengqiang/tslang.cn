<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>举例 · 声明文件 · TypeScript中文网 · TypeScript——JavaScript的超集</title>
    <!-- inject:css -->
    <!-- endinject -->
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/icons/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/icons/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/assets/images/icons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/assets/images/icons/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/assets/images/icons/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/assets/images/icons/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/assets/images/icons/manifest.json">
    <link rel="mask-icon" href="/assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="/assets/images/icons/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/assets/images/icons/mstile-144x144.png">
    <meta name="msapplication-config" content="/assets/images/icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <!-- <script id="twitter-wjs" src="https://platform.twitter.com/widgets.js"></script> -->
    <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> -->
</head>

<body>
</body>
<!-- inject:header:html -->
<!-- endinject -->
<!-- inject:message:html -->
<!-- endinject -->
<div id="content" class="container-fluid fill docs-container">
    <div class="container">
        <div class="col-md-3 toc-container">
            <!-- inject:docs-nav:html -->
            <!-- endinject -->
        </div>
        <div class="col-md-9 col-xs-12 col-sm-12 doc-content-container">
            <header class="post-header">
                <h1 class="post-title">举例</h1>
            </header>
            <article class="post-content">
                <h1>简介</h1>
                <p>这篇指南的目的是教你如何书写高质量的TypeScript声明文件。 我们在这里会展示一些API的文档，还有它们的使用示例， 并且阐述了如何为它们书写声明文件。
                </p>
                <p>这些例子是按复杂度递增的顺序组织的。</p>
                <ul>
                    <li><a href="#global-variables">全局变量</a></li>
                    <li><a href="#global-functions">全局函数</a></li>
                    <li><a href="#objects-with-properties">带属性的对象</a></li>
                    <li><a href="#overloaded-functions">函数重载</a></li>
                    <li><a href="#reusable-types-interfaces">可重用类型（接口）</a></li>
                    <li><a href="#reusable-types-type-aliases">可重用类型（类型别名）</a></li>
                    <li><a href="#organizing-types">组织类型</a></li>
                    <li><a href="#classes">类</a></li>
                </ul>
                <h1>例子</h1>
                <h2>
                    <a name="global-variables"></a>全局变量</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p>全局变量<code>foo</code>包含了存在组件总数。</p>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">console.log(&quot;Half the number of widgets is &quot; + (foo / 2));
</code></pre>
                <p><em>声明</em></p>
                <p>使用<code>declare var</code>声明变量。 如果变量是只读的，那么可以使用
                    <code>declare const</code>。 你还可以使用
                    <code>declare let</code>如果变量拥有块级作用域。</p>
                <pre><code class="language-ts">/** 组件总数 */
declare var foo: number;
</code></pre>
                <h2>
                    <a name="global-functions"></a>全局函数</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p>用一个字符串参数调用<code>greet</code>函数向用户显示一条欢迎信息。</p>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">greet(&quot;hello, world&quot;);
</code></pre>
                <p><em>声明</em></p>
                <p>使用<code>declare function</code>声明函数。</p>
                <pre><code class="language-ts">declare function greet(greeting: string): void;
</code></pre>
                <h2>
                    <a name="objects-with-properties"></a>带属性的对象</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p>全局变量<code>myLib</code>包含一个<code>makeGreeting</code>函数， 还有一个属性
                        <code>numberOfGreetings</code>指示目前为止欢迎数量。</p>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">let result = myLib.makeGreeting(&quot;hello, world&quot;);
console.log(&quot;The computed greeting is:&quot; + result);

let count = myLib.numberOfGreetings;
</code></pre>
                <p><em>声明</em></p>
                <p>使用<code>declare namespace</code>描述用点表示法访问的类型或值。</p>
                <pre><code class="language-ts">declare namespace myLib {
    function makeGreeting(s: string): string;
    let numberOfGreetings: number;
}
</code></pre>
                <h2>
                    <a name="overloaded-functions"></a>函数重载</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p><code>getWidget</code>函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。</p>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">let x: Widget = getWidget(43);

let arr: Widget[] = getWidget(&quot;all of them&quot;);
</code></pre>
                <p><em>声明</em></p>
                <pre><code class="language-ts">declare function getWidget(n: number): Widget;
declare function getWidget(s: string): Widget[];
</code></pre>
                <h2>
                    <a name="reusable-types-interfaces"></a>可重用类型（接口）</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p>当指定一个欢迎词时，你必须传入一个<code>GreetingSettings</code>对象。 这个对象具有以下几个属性：
                    </p>
                    <ul>
                        <li>greeting：必需的字符串</li>
                        <li>duration: 可靠的时长（毫秒表示）</li>
                        <li>color: 可选字符串，比如‘#ff00ff’</li>
                    </ul>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">greet({
  greeting: &quot;hello world&quot;,
  duration: 4000
});
</code></pre>
                <p><em>声明</em></p>
                <p>使用<code>interface</code>定义一个带有属性的类型。</p>
                <pre><code class="language-ts">interface GreetingSettings {
  greeting: string;
  duration?: number;
  color?: string;
}

declare function greet(setting: GreetingSettings): void;
</code></pre>
                <h2>
                    <a name="reusable-types-type-aliases"></a>可重用类型（类型别名）</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p>在任何需要欢迎词的地方，你可以提供一个<code>string</code>，一个返回<code>string</code>的函数或一个<code>Greeter</code>实例。</p>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">function getGreeting() {
    return &quot;howdy&quot;;
}
class MyGreeter extends Greeter { }

greet(&quot;hello&quot;);
greet(getGreeting);
greet(new MyGreeter());
</code></pre>
                <p><em>声明</em></p>
                <p>你可以使用类型别名来定义类型的短名：</p>
                <pre><code class="language-ts">type GreetingLike = string | (() =&gt; string) | Greeting;

declare function greet(g: GreetingLike): void;
</code></pre>
                <h2>
                    <a name="organizing-types"></a>组织类型</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p><code>greeter</code>对象能够记录到文件或显示一个警告。 你可以为
                        <code>.log(...)</code>提供LogOptions和为<code>.alert(...)</code>提供选项。</p>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">const g = new Greeter(&quot;Hello&quot;);
g.log({ verbose: true });
g.alert({ modal: false, title: &quot;Current Greeting&quot; });
</code></pre>
                <p><em>声明</em></p>
                <p>使用命名空间组织类型。</p>
                <pre><code class="language-ts">declare namespace GreetingLib {
    interface LogOptions {
        verbose?: boolean;
    }
    interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
                <p>你也可以在一个声明中创建嵌套的命名空间：</p>
                <pre><code class="language-ts">declare namespace GreetingLib.Options {
    // Refer to via GreetingLib.Options.Log
    interface Log {
        verbose?: boolean;
    }
    interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
                <h2>
                    <a name="classes"></a>类</h2>
                <p><em>文档</em></p>
                <blockquote>
                    <p>你可以通过实例化<code>Greeter</code>对象来创建欢迎词，或者继承<code>Greeter</code>对象来自定义欢迎词。</p>
                </blockquote>
                <p><em>代码</em></p>
                <pre><code class="language-ts">const myGreeter = new Greeter(&quot;hello, world&quot;);
myGreeter.greeting = &quot;howdy&quot;;
myGreeter.showGreeting();

class SpecialGreeter extends Greeter {
    constructor() {
        super(&quot;Very special greetings&quot;);
    }
}
</code></pre>
                <p><em>声明</em></p>
                <p>使用<code>declare class</code>描述一个类或像类一样的对象。 类可以有属性和方法，就和构造函数一样。
                </p>
                <pre><code class="language-ts">declare class Greeter {
    constructor(greeting: string);

    greeting: string;
    showGreeting(): void;
}
</code></pre>
            </article>
        </div>
    </div>
</div>
<!-- inject:footer:html -->
<!-- endinject -->
<!-- inject:js -->
<!-- endinject -->

</html>